#!/bin/bash

# Safe SQLite database backup script using official SQLite backup command
# Backs up the jsproxy database to $HOME with timestamp

set -e  # Exit on error

# Configuration
DB_PATH="$(dirname "$0")/../data/current.db"
BACKUP_DIR="$HOME"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_FILE="${BACKUP_DIR}/jsproxy_${TIMESTAMP}.db"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if database exists
if [ ! -f "$DB_PATH" ]; then
    echo -e "${RED}Error: Database file not found at $DB_PATH${NC}"
    exit 1
fi

# Check if backup directory is writable
if [ ! -w "$BACKUP_DIR" ]; then
    echo -e "${RED}Error: Cannot write to backup directory $BACKUP_DIR${NC}"
    exit 1
fi

# Check if sqlite3 is available
if ! command -v sqlite3 &> /dev/null; then
    echo -e "${RED}Error: sqlite3 command not found. Please install sqlite3.${NC}"
    exit 1
fi

echo -e "${YELLOW}Starting database backup...${NC}"
echo "  Source: $DB_PATH"
echo "  Destination: $BACKUP_FILE"

# Perform the backup using SQLite's official .backup command
# This is the SAFE way to backup - it handles open databases and WAL mode correctly
sqlite3 "$DB_PATH" ".backup '$BACKUP_FILE'"

# Verify the backup was created and has content
if [ -f "$BACKUP_FILE" ] && [ -s "$BACKUP_FILE" ]; then
    BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
    echo -e "${GREEN}✓ Backup completed successfully!${NC}"
    echo "  File: $BACKUP_FILE"
    echo "  Size: $BACKUP_SIZE"

    # Verify the backup is a valid SQLite database
    if sqlite3 "$BACKUP_FILE" "PRAGMA integrity_check;" > /dev/null 2>&1; then
        echo -e "${GREEN}✓ Backup integrity verified${NC}"
    else
        echo -e "${YELLOW}⚠ Warning: Backup file may have integrity issues${NC}"
        exit 1
    fi
else
    echo -e "${RED}✗ Backup failed - file not created or empty${NC}"
    exit 1
fi
